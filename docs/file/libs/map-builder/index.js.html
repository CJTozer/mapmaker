<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">libs/map-builder/index.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/CJTozer/mapmaker" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">map-builder</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/libs/map-builder/index.js~MapBuilder.html">MapBuilder</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">libs/map-builder/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">#!/usr/bin/env node
&apos;use strict&apos;;

const
  async = require( &apos;async&apos; ),
  chalk = require( &apos;chalk&apos; ),
  Config = require( &apos;merge-config&apos; ),
  css = require( &apos;node-css&apos; ),
  d3 = require( &apos;d3&apos; ),
  download = require( &apos;download&apos; ),
  fs = require( &apos;fs-extra&apos; ),
  hash = require( &apos;object-hash&apos; ),
  jsdom = require( &apos;jsdom&apos; ),
  ogr2ogr = require( &apos;ogr2ogr&apos; ),
  path = require( &apos;path&apos; ),
  projections = require( &apos;../projections&apos; ),
  urljoin = require( &apos;url-join&apos; ),
  utils = require( &apos;../utils&apos; );

/**
 * Class for encapsulating a map building operation.
 * @example
 * new MapBuilder()
 *   .specFile(&apos;examples/france.yaml&apos;)
 *   .onError((err) =&gt; {
 *     console.log(err);
 *   })
 *   .onSuccess((data) =&gt; {
 *     console.log(&quot;Success&quot;);
 *     do_something_with_svg_data(data);
 *   })
 *   .build_map();
 */
class MapBuilder {
  constructor() {
    var self = this;
    self.config = {};
    self.data = {};
    self.spec_obj = {};
    self.spec_file = &apos;&apos;;
    self.output_exists = false;
    self.css_string = &apos;&apos;;
    self.svg_text = &apos;Failed to build SVG&apos;;
  }

  /**
   * Specify an error callback for this {@link MapBuilder}.
   *
   * @param {function(err: string)} err_cb - the error callback.
   */
  onError( err_cb ) {
    this.err_cb = err_cb;
    return this;
  }

  /**
   * Specify a success callback for this {@link MapBuilder}.
   *
   * @param {function(data: string)} ok_cb - the success callback, passed the generated SVG as a string.
   */
  onSuccess( ok_cb ) {
    this.ok_cb = ok_cb;
    return this;
  }

  /**
   * Specify the configuration to use.
   *
   * May be used in conjunction with {@link specFile}.  They will be merged with the
   * spec_obj taking precedence in case of clashes.
   *
   * @param {!Object} spec_obj - object describing the configuration to use.
   * @example
   * var spec_obj = {
   *   &quot;parameters&quot;: {
   *     &quot;projection&quot;: {
   *       &quot;type&quot;: &quot;mercator&quot;,
   *       &quot;width&quot;: 960,
   *       &quot;height&quot;: 1120,
   *       &quot;scale&quot;: 1600,
   *       &quot;center&quot;: [2, 50]
   *     }
   *   }
   * }
   * new MapBuilder()
   *   .spec(spec_obj)
   *   // (Register .onError and .onSuccess callbacks.)
   *   .build_map();
   */
  spec( spec_obj ) {
    this.spec_obj = spec_obj;
    return this;
  }

  /**
   * Specify the configuration to use.
   *
   * May be used in conjunction with {@link spec}.  They will be merged with the
   * spec_obj taking precedence in case of clashes.
   *
   * @param {string} spec_file - configuration file to use.
   */
  specFile( spec_file ) {
    this.spec_file = spec_file;
    return this;
  }

  /**
   * Specify whether to force a rebuild.
   *
   * Normally maps are cached based on the specification, but if you update
   * this module you may want to use this option to force the map to be
   * re-created.
   *
   * @param {boolean} force - whether to force map re-creation.
   */
  force( force ) {
    this.force = force;
    return this;
  }

  /**
   * Asynchronously build the map.
   *
   * Requires {@link onError} and {@link onSuccess} specified to handle the
   * results.
   */
  build_map() {
    var self = this;
    async.series( {
      build_config: ( callback ) =&gt; {
        console.log( chalk.bold.cyan( &apos;Building config...&apos; ) );
        self.build_config( callback, self.spec_file );
      },
      check_for_existing_output: ( callback ) =&gt; {
        fs.readFile( self.config.derived.output_svg, function( err, data ) {
          if ( !err &amp;&amp; !self.force ) {
            console.log( chalk.bold.yellow( &apos;Output already generated: &apos; ) + self.config.derived.output_svg );
            self.output_exists = true;
            self.svg_text = data;
          }
          return callback( null );
        } );
      },
      get_data_files: ( callback ) =&gt; {
        if ( !self.output_exists ) {
          console.log( chalk.bold.cyan( &apos;Checking data sources...&apos; ) );
          self.get_data_files( callback );
        } else {
          return callback( null );
        }
      },
      filter_data: ( callback ) =&gt; {
        if ( !self.output_exists ) {
          console.log( chalk.bold.cyan( &apos;Filtering data...&apos; ) );
          self.filter_data( callback );
        } else {
          return callback( null );
        }
      },
      build_css: ( callback ) =&gt; {
        if ( !self.output_exists ) {
          console.log( chalk.bold.cyan( &apos;Generating CSS...&apos; ) );
          self.build_css( callback );
        } else {
          return callback( null );
        }
      },
      create_svg: ( callback ) =&gt; {
        if ( !self.output_exists ) {
          console.log( chalk.bold.cyan( &apos;Creating SVG...&apos; ) );
          self.create_svg( callback );
        } else {
          return callback( null );
        }
      },
    }, function( err ) {
      if ( err ) {
        console.log( chalk.bold.red( &apos;Failed!  &apos; ) + err );
        if ( self.err_cb ) {
          self.err_cb( err );
        }
      } else {
        console.log( chalk.bold.green( &apos;Map Building Complete!&apos; ) );
        if ( self.ok_cb ) {
          self.ok_cb( self.svg_text );
        }
      }
    } );
  }

  /**
   * Print information from the shape file specified in the config.
   *
   * Requires {@link onError} and {@link onSuccess} specified to handle the
   * results.
   */
  get_shape_info() {
    var self = this;
    async.series( {
      build_config: ( callback ) =&gt; {
        console.log( chalk.bold.cyan( &apos;Building config...&apos; ) );
        self.build_config( callback, self.spec_file );
      },
      get_data_files: ( callback ) =&gt; {
        console.log( chalk.bold.cyan( &apos;Checking data sources...&apos; ) );
        self.get_data_files( callback );
      },
      get_shape_info: ( callback ) =&gt; {
        console.log( chalk.bold.cyan( &apos;Getting shape info...&apos; ) );
        // @@@ Option to apply filter first.
        // @@@ Get format from repo config?
        ogr2ogr( self.config.derived.shape_file )
          .format( &apos;GeoJSON&apos; )
          .exec( function( err, geo_data ) {
            if ( err ) {
              return callback( err );
            }
            self.data = geo_data;
            return callback( null );
          } );
      },
    }, function( err ) {
      if ( err ) {
        console.log( chalk.bold.red( &apos;Failed!  &apos; ) + err );
        if ( self.err_cb ) {
          self.err_cb( err );
        }
      } else {
        console.log( chalk.bold.green( &apos;Parsed shape info!&apos; ) );
        if ( self.ok_cb ) {
          self.ok_cb( self.data );
        }
      }
    } );
  }

  /**
   * Build up the configuration.
   * @access private
   */
  build_config( callback ) {
    var
      self = this,
      built_config,
      shape_data,
      file_base,
      shape_dir,
      repo_info,
      sha;

    // Get the global defaults then override with the specified specification.
    built_config = new Config();
    built_config.file( path.join( __dirname, &apos;..&apos;, &apos;..&apos;, &apos;defaults.yaml&apos; ) );
    if ( self.spec_file ) {
      built_config.file( self.spec_file );
    }
    if ( self.spec_obj ) {
      built_config.merge( self.spec_obj );
    }
    utils.debug( &apos;Pure Config&apos;, self.config );

    // Set up derived config values:
    // - Download dirs and shapefile name
    shape_data = built_config.get( &apos;shape_data&apos; );
    file_base = shape_data.filename.substr( 0, shape_data.filename.lastIndexOf( &apos;.&apos; ) ) || shape_data.filename;
    shape_dir = path.join( &apos;data&apos;, shape_data.repo, shape_data.base, file_base );
    built_config.set( &apos;derived:shape_dir&apos;, shape_dir );
    built_config.set( &apos;derived:shape_file&apos;, path.join( shape_dir, file_base + &apos;.shp&apos; ) );

    // - Info for the current repo
    repo_info = built_config.get( &apos;repos&apos; )[ shape_data.repo ];
    built_config.set( &apos;derived:repo_info&apos;, repo_info );

    // - Download target
    built_config.set( &apos;derived:download_url&apos;, urljoin( repo_info.base_url, shape_data.base, shape_data.filename ) );

    // - SHA of the spec file, and output file.
    sha = hash( built_config.get() );
    built_config.set( &apos;derived:spec_sha1&apos;, sha );
    built_config.set( &apos;derived:output_svg&apos;, path.join( &apos;output&apos;, sha + &apos;.svg&apos; ) );

    // Store off the config as a &apos;normal&apos; object.
    self.config = built_config.get();
    utils.debug( &apos;Full Config&apos;, self.config );
    return callback( null );
  }

  /**
   * Ensure raw data is available.
   * @access private
   */
  get_data_files( callback ) {
    var self = this;

    // Get the destination and check for existing data.
    fs.access( self.config.derived.shape_dir, ( err ) =&gt; {
      if ( !err ) {
        console.log( chalk.bold.yellow( &apos;Data already available: &apos; ) + self.config.derived.shape_dir );
        return callback( null );
      } else {
        // Directory doesn&apos;t exist, proceed with download.
        console.log( chalk.bold.cyan( &apos;Downloading data: &apos; ) + self.config.derived.download_url );
        // @@@ Get extract value from spec file...
        download( self.config.derived.download_url, self.config.derived.shape_dir, {
          extract: true,
        } ).then( () =&gt; {
          return callback( null );
        }, ( err ) =&gt; {
          return callback( err );
        } );
      }
    } );
  }

  /**
   * Filter data using ogr2ogr.
   * @access private
   */
  filter_data( callback ) {
    var
      self = this,
      values,
      options = [],
      filter;
    utils.debug( &apos;Countries config&apos;, self.config.parameters.countries );
    utils.debug( &apos;Filter&apos;, self.config.parameters.filter );
    filter = self.config.parameters.filter;
    if ( filter ) {
      switch ( filter.type ) {
      case &apos;countries&apos;:
        if ( !self.config.parameters.countries ) {
          return callback( &apos;Cannot filter on countries with no countries specified - use &quot;type: all&quot;&apos; );
        }
        values = Object.keys( self.config.parameters.countries ).join( &apos;\&apos;, \&apos;&apos; );
        options = options.concat( [ &apos;-where&apos;, `${filter.key} IN (\&apos;${values}\&apos;)` ] );
        break;
      case &apos;all&apos;:
          // Include all countries - no filter
        break;
      default:
        return callback( `Unknown value for &quot;filter&quot;: ${filter.type}` );
      }
    }
    // @@@ Get format from repo config?
    ogr2ogr( self.config.derived.shape_file )
      .format( &apos;GeoJSON&apos; )
      .options( options )
      .exec( function( err, geo_data ) {
        if ( err ) {
          return callback( err );
        }
        self.data = geo_data;
        return callback( null );
      } );
  }

  /**
   * Generate the CSS.
   * @access private
   */
  build_css( callback ) {
    var
      self = this,
      base_style = self.config.style,
      countries;
    Object.keys( base_style ).forEach( ( key ) =&gt; {
      var data = base_style[ key ];
      if ( data ) {
        self.css_string += css( key, data );
      }
    } );

    // Per-country CSS.
    countries = self.config.parameters.countries;
    if ( countries ) {
      Object.keys( countries ).forEach( ( key ) =&gt; {
        var data = countries[ key ];
        if ( data ) {
          self.css_string += css( `.ADM0_A3-${key}`, data );
        }
      } );
    }
    utils.debug( &apos;Generated CSS&apos;, self.css_string );
    return callback( null );
  }

  /**
   * Create the SVG file.
   * @access private
   */
  create_svg( callback ) {
    var self = this;
    // Use jsdom to create a fake DOM to work in.
    jsdom.env( &apos;&lt;body /&gt;&apos;,
      function( err, window ) {
        var
          body,
          svg,
          path;
        if ( err ) {
          return callback( err );
        }

        // Create an SVG element for the map.
        body = d3.select( window.document ).select( &apos;body&apos; );
        svg = body.append( &apos;svg&apos; )
          .attr( &apos;width&apos;, self.config.parameters.projection.width )
          .attr( &apos;height&apos;, self.config.parameters.projection.height );

        let {
          proj_err,
          projection,
        } = projections.get_projection( self.config );
        if ( proj_err ) {
          return callback( proj_err );
        }
        path = d3.geoPath()
          .projection( projection );

        // Add an appropriate class to each country.
        svg.selectAll( &apos;.country&apos; )
          .data( self.data.features )
          .enter().append( &apos;path&apos; )
          .attr( &apos;class&apos;, function( d ) {
            return [
              &apos;ADM0_A3-&apos; + d.properties.ADM0_A3,
              &apos;SU_A3-&apos; + d.properties.SU_A3,
              &apos;GU_A3-&apos; + d.properties.GU_A3,
            ].join( &apos; &apos; );
          } )
          .attr( &apos;d&apos;, path );

        // Add in the CSS style.
        svg.append( &apos;style&apos; ).text( self.css_string );

        // Write SVG to the output directory.
        // Write body.html() to the SVG file as this is effectively svg.outerHTML.
        if ( !fs.existsSync( &apos;output&apos; ) ) {
          fs.mkdirSync( &apos;output&apos; );
        }
        self.svg_text = body.html();
        fs.writeFile( self.config.derived.output_svg, self.svg_text, function( err ) {
          if ( err ) {
            console.log( err );
            return callback( err );
          }

          console.log( &apos;Saved to &apos; + self.config.derived.output_svg );
          return callback( null );
        } );
      }
    );
  }
}

// Export the MapBuilder class.
module.exports = MapBuilder;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
